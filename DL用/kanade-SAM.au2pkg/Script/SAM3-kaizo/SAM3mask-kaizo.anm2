--label:クリッピング
--information:SAM3で生成したマスク動画を使ってアルファ(透明度)を作成
--script:lua

--file@path:マスク動画ファイル
--track@offset:オフセット,0,50000,0,0.001
--check@invert:反転,false
--value@mask_src_start:元動画開始秒,0
--value@mask_src_end:元動画終了秒,0

local mod = obj.module("sam3mask-kaizo")

local base, bw, bh = obj.getpixeldata("object")

obj.setoption("drawtarget","tempbuffer")

-- マスク動画が未指定なら何もしない
if path == nil or path == "" then
  obj.setoption("drawtarget","framebuffer")
  obj.putpixeldata("object", base, bw, bh, "rgba")
  return
end

-- ------------------------------------------------------------
-- 同期方針:
--  1) 「動画ファイル」効果の現在値(再生位置/再生速度)から “元動画の現在時刻” を推定
--  2) マスク動画は「元動画開始秒(mask_src_start)」を基準に生成されているので
--     mask_t = (src_t - mask_src_start) + offset でシーク
--  3) マスク範囲外は (0..mask_src_end-mask_src_start) にクランプ
-- ------------------------------------------------------------

local function tonumber_safe(v)
  if v == nil then return nil end
  local n = tonumber(v)
  return n
end

local function parse_two_numbers_csv(s)
  if s == nil then return nil, nil end
  -- 例: "0.000,0.733,再生範囲,0" の先頭2つだけ読む
  local a, b = tostring(s):match("^%s*([%+%-]?%d*%.?%d+)%s*,%s*([%+%-]?%d*%.?%d+)")
  if a == nil then return nil, nil end
  return tonumber(a), tonumber(b)
end

-- obj.getvalue の互換吸収（環境によっては第2引数が数値(time)を要求して落ちる）
-- なので「失敗しても例外を出さず nil を返す」+「引数個数違いを試す」。
local function safe_call(f)
  local ok, v = pcall(f)
  if ok then return v end
  return nil
end

local function get_time_seconds()
  -- Prefer obj.getvalue("time") because it is consistently seconds in AviUtl2 scripts.
  local t = tonumber_safe(safe_call(function() return obj.getvalue("time") end))
  if t == nil then t = tonumber_safe(obj.time) end
  if t == nil then t = 0.0 end
  return t
end

local function get_totaltime_seconds()
  local tt = tonumber_safe(safe_call(function() return obj.getvalue("totaltime") end))
  if tt == nil then tt = tonumber_safe(obj.totaltime) end
  if tt == nil or tt <= 0 then tt = 0.0 end
  return tt
end

local function get_effect_item_value(effect_name, item_name)
  local t = get_time_seconds()
  -- 確定: obj.getvalue(effect,item,time,section)
  return safe_call(function() return obj.getvalue(effect_name, item_name, t, 0) end)
end

local function get_video_playback_range()
  -- 日本語UI/英語UIの両対応（取れた方を使う）
  local s = get_effect_item_value("動画ファイル", "再生位置")
  if s == nil then s = get_effect_item_value("Video File", "Playback") end
  if s == nil then s = get_effect_item_value("映像再生", "再生位置") end
  if s == nil then s = get_effect_item_value("Movie Playback", "Playback") end

  -- 返り値が number / string / その他でも極力拾う
  if type(s) == "number" then
    return s, nil
  end
  return parse_two_numbers_csv(s)
end

local function get_video_speed_percent()
  local s = get_effect_item_value("動画ファイル", "再生速度")
  if s == nil then s = get_effect_item_value("Video File", "Playback Speed") end
  if s == nil then s = get_effect_item_value("映像再生", "再生速度") end
  if s == nil then s = get_effect_item_value("Movie Playback", "Playback Speed") end
  local v = tonumber_safe(s) or (type(s) == "number" and s) or 100.0
  if v <= 0 then v = 100.0 end
  return v
end

-- 現在の「動画ファイル」効果が示す再生範囲/速度を取得
local pb0, pb1 = get_video_playback_range()
local sp = get_video_speed_percent()

-- 元動画の開始/終了秒（マスク生成時の基準）。
-- 変数キー読み込み失敗時は、再生位置からフォールバックして同期ズレを防ぐ。
local src0_raw = tonumber_safe(mask_src_start)
local src1_raw = tonumber_safe(mask_src_end)
local src0 = src0_raw
local src1 = src1_raw
if src0 == nil then
  src0 = (pb0 ~= nil) and pb0 or 0.0
end
if src1 == nil then
  src1 = (pb1 ~= nil) and pb1 or src0
end

-- フォールバック（再生位置が取れない場合は従来挙動）
local src_t
if pb0 ~= nil then
  src_t = pb0 + (get_time_seconds() * (sp / 100.0))
else
  local tt = get_totaltime_seconds()
  local now_t = get_time_seconds()
  if tt > 0 then
    src_t = (now_t % tt)
  else
    src_t = now_t
  end
end

-- マスク側シーク時刻（秒）
local t = (src_t - src0) + (tonumber_safe(offset) or 0.0)

-- マスク範囲外はクランプ（生成範囲だけマスク保持の方針）
if src1 > src0 then
  local dur = src1 - src0
  if t < 0 then t = 0 end
  if t > dur then t = dur end
else
  if t < 0 then t = 0 end
end

obj.load("movie", path, t)

-- RGBAデータ取得
local mask, mw, mh = obj.getpixeldata("object")

local w = bw
local h = bh
if mw ~= bw or mh ~= bh then
  w = math.min(bw, mw)
  h = math.min(bh, mh)
end

mod.apply_alpha(base, mask, w, h, invert)

-- 結果を書き戻す
obj.setoption("drawtarget","framebuffer")
obj.putpixeldata("object", base, bw, bh, "rgba")
